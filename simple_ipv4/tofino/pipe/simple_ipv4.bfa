version:
  run_id: "a20a2ade19ce4d98"
  target: Tofino
error_mode: propagate_and_disable
phv ingress:
  hdr.ethernet.dstAddr.0-31: TW3
  hdr.ethernet.dstAddr.32-47: TH4
  hdr.ethernet.srcAddr.0-31: TW2
  hdr.ethernet.srcAddr.32-47: TH3
  hdr.ethernet.etherType: TH2
  hdr.ipv4.version: TW0(28..31)
  hdr.ipv4.ihl: TW0(24..27)
  hdr.ipv4.diffserv: TW0(16..23)
  hdr.ipv4.totalLen: TW0(0..15)
  hdr.ipv4.identification: TW1(16..31)
  hdr.ipv4.flags: TW1(13..15)
  hdr.ipv4.fragOffset: TW1(0..12)
  hdr.ipv4.ttl: B0
  hdr.ipv4.protocol: TB0
  hdr.ipv4.hdrChecksum: TH5
  hdr.ipv4.srcAddr.0-15: TH0
  hdr.ipv4.srcAddr.16-31: TH1
  hdr.ipv4.dstAddr: W0
  ig_intr_md_for_tm.ucast_egress_port: {  stage 1..12: H0(0..8) } 
  ig_intr_md_for_dprsr.drop_ctl: {  stage 1..12: B2(0..2) } 
  ig_intr_md_for_dprsr.mirror_type: {  stage 12: B1(0..2) } 
  $tmp2: {  stage 12: H1(0..9) } 
  hdr.ethernet.$valid: B3(0)
  hdr.ipv4.$valid: B3(1)
  context_json:
    B0:
    - { name : hdr.ipv4.ttl, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    B1:
    - { name : ig_intr_md_for_dprsr.mirror_type, live_start : deparser, live_end : deparser, mutually_exclusive_with: [  ] }
    B2:
    - { name : ig_intr_md_for_dprsr.drop_ctl, live_start : 1, live_end : deparser, mutually_exclusive_with: [  ] }
    B3:
    - { name : hdr.ethernet.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.ipv4.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    H0:
    - { name : ig_intr_md_for_tm.ucast_egress_port, live_start : 1, live_end : deparser, mutually_exclusive_with: [  ] }
    H1:
    - { name : $tmp2, live_start : deparser, live_end : deparser, mutually_exclusive_with: [  ] }
    W0:
    - { name : hdr.ipv4.dstAddr, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
phv egress:
  eg_intr_md.egress_port: H16(0..8)
  hdr.ethernet.dstAddr.0-31: W17
  hdr.ethernet.dstAddr.32-47: H18
  hdr.ethernet.srcAddr.0-31: W16
  hdr.ethernet.srcAddr.32-47: H17
  hdr.ethernet.etherType: TH12
  hdr.ipv4.version: TW4(28..31)
  hdr.ipv4.ihl: TW4(24..27)
  hdr.ipv4.diffserv: TW4(16..23)
  hdr.ipv4.totalLen: TW4(0..15)
  hdr.ipv4.identification: TW6(16..31)
  hdr.ipv4.flags: TW6(13..15)
  hdr.ipv4.fragOffset: TW6(0..12)
  hdr.ipv4.ttl: TW5(24..31)
  hdr.ipv4.protocol: TW5(16..23)
  hdr.ipv4.hdrChecksum: TW5(0..15)
  hdr.ipv4.srcAddr.0-15: TH6
  hdr.ipv4.srcAddr.16-31: TH7
  hdr.ipv4.dstAddr: TW7
  hdr.min_parse_depth_padding_0$0.packet_payload.0-15: TH8
  hdr.min_parse_depth_padding_0$0.packet_payload.16-31: TH9
  hdr.min_parse_depth_padding_0$0.packet_payload.32-47: TH10
  hdr.min_parse_depth_padding_0$0.packet_payload.48-63: TH11
  hdr.min_parse_depth_padding_0$0.packet_payload.64-79: TH13
  hdr.min_parse_depth_padding_0$0.packet_payload.80-87: TB4
  hdr.min_parse_depth_padding_0$1.packet_payload.0-31: TW8
  hdr.min_parse_depth_padding_0$1.packet_payload.32-63: TW9
  hdr.min_parse_depth_padding_0$1.packet_payload.64-79: TH14
  hdr.min_parse_depth_padding_0$1.packet_payload.80-87: TB5
  hdr.min_parse_depth_padding_0$2.packet_payload.0-31: TW10
  hdr.min_parse_depth_padding_0$2.packet_payload.32-63: TW11
  hdr.min_parse_depth_padding_0$2.packet_payload.64-79: TH15
  hdr.min_parse_depth_padding_0$2.packet_payload.80-87: TB6
  hdr.ethernet.$valid: B17(0)
  hdr.ipv4.$valid: B17(1)
  hdr.min_parse_depth_padding_0.$stkvalid: B16(0..2)
  hdr.min_parse_depth_padding_0$0.$valid: {  stage 12: B16(2) } 
  hdr.min_parse_depth_padding_0$1.$valid: {  stage 12: B16(1) } 
  hdr.min_parse_depth_padding_0$2.$valid: B16(0)
  context_json:
    B16:
    - { name : hdr.min_parse_depth_padding_0$2.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.min_parse_depth_padding_0.$stkvalid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.min_parse_depth_padding_0$0.$valid, live_start : deparser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.min_parse_depth_padding_0$1.$valid, live_start : deparser, live_end : deparser, mutually_exclusive_with: [  ] }
    B17:
    - { name : hdr.ethernet.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.ipv4.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    H16:
    - { name : eg_intr_md.egress_port, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    H17:
    - { name : hdr.ethernet.srcAddr, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    H18:
    - { name : hdr.ethernet.dstAddr, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    W16:
    - { name : hdr.ethernet.srcAddr, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    W17:
    - { name : hdr.ethernet.dstAddr, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
parser ingress:
  start: $init_match
  init_zero: [ B2, B1, H1, B3 ]
  bitwise_or: [ B3 ]
  hdr_len_adj: 16
  states:
    $init_match:
      *:
        16..17: TH4  # ingress::hdr.ethernet.dstAddr[47:32].32-47
        18..21: TW3  # ingress::hdr.ethernet.dstAddr[31:0].0-31
        22..23: TH3  # ingress::hdr.ethernet.srcAddr[47:32].32-47
        24..27: TW2  # ingress::hdr.ethernet.srcAddr[31:0].0-31
        28..29: TH2  # ingress::hdr.ethernet.etherType
        B3: 1  # value 1 -> B3 bit[0]: ingress::hdr.ethernet.$valid
        load: { half : 28..29 }
        shift: 30
        buf_req: 30
        next: $entry_point.start
    $entry_point.start:
      match: [ half ]
      0x0800:
        0..3: TW0
            # - bit[0..3] -> TW0 bit[31..28]: ingress::hdr.ipv4.version
            # - bit[4..7] -> TW0 bit[27..24]: ingress::hdr.ipv4.ihl
            # - bit[8..15] -> TW0 bit[23..16]: ingress::hdr.ipv4.diffserv
            # - bit[16..31] -> TW0 bit[15..0]: ingress::hdr.ipv4.totalLen
        4..7: TW1
            # - bit[32..47] -> TW1 bit[31..16]: ingress::hdr.ipv4.identification
            # - bit[48..50] -> TW1 bit[15..13]: ingress::hdr.ipv4.flags
            # - bit[51..63] -> TW1 bit[12..0]: ingress::hdr.ipv4.fragOffset
        8: B0  # ingress::hdr.ipv4.ttl
        9: TB0  # ingress::hdr.ipv4.protocol
        10..11: TH5  # ingress::hdr.ipv4.hdrChecksum
        12..13: TH1  # ingress::hdr.ipv4.srcAddr[31:16].16-31
        14..15: TH0  # ingress::hdr.ipv4.srcAddr[15:0].0-15
        16..19: W0  # ingress::hdr.ipv4.dstAddr
        B3: 2  # value 1 -> B3 bit[1]: ingress::hdr.ipv4.$valid
        shift: 20
        buf_req: 20
        next: end
      0x****:
        buf_req: 0
        next: end
deparser ingress:
  dictionary:
    TH4: B3(0)  # ingress::hdr.ethernet.dstAddr.32-47 if ingress::hdr.ethernet.$valid
    TW3: B3(0)  # ingress::hdr.ethernet.dstAddr.0-31 if ingress::hdr.ethernet.$valid
    TH3: B3(0)  # ingress::hdr.ethernet.srcAddr.32-47 if ingress::hdr.ethernet.$valid
    TW2: B3(0)  # ingress::hdr.ethernet.srcAddr.0-31 if ingress::hdr.ethernet.$valid
    TH2: B3(0)  # ingress::hdr.ethernet.etherType if ingress::hdr.ethernet.$valid
    TW0: B3(1)
        # - bit[31..28]: ingress::hdr.ipv4.version if ingress::hdr.ipv4.$valid
        # - bit[27..24]: ingress::hdr.ipv4.ihl if ingress::hdr.ipv4.$valid
        # - bit[23..16]: ingress::hdr.ipv4.diffserv if ingress::hdr.ipv4.$valid
        # - bit[15..0]: ingress::hdr.ipv4.totalLen if ingress::hdr.ipv4.$valid
    TW1: B3(1)
        # - bit[31..16]: ingress::hdr.ipv4.identification if ingress::hdr.ipv4.$valid
        # - bit[15..13]: ingress::hdr.ipv4.flags if ingress::hdr.ipv4.$valid
        # - bit[12..0]: ingress::hdr.ipv4.fragOffset if ingress::hdr.ipv4.$valid
    B0: B3(1)  # ingress::hdr.ipv4.ttl if ingress::hdr.ipv4.$valid
    TB0: B3(1)  # ingress::hdr.ipv4.protocol if ingress::hdr.ipv4.$valid
    TH5: B3(1)  # ingress::hdr.ipv4.hdrChecksum if ingress::hdr.ipv4.$valid
    TH1: B3(1)  # ingress::hdr.ipv4.srcAddr.16-31 if ingress::hdr.ipv4.$valid
    TH0: B3(1)  # ingress::hdr.ipv4.srcAddr.0-15 if ingress::hdr.ipv4.$valid
    W0: B3(1)  # ingress::hdr.ipv4.dstAddr if ingress::hdr.ipv4.$valid
  egress_unicast_port: H0(0..8)  # bit[8..0]: ingress::ig_intr_md_for_tm.ucast_egress_port
  drop_ctl: B2(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.drop_ctl
  mirror:
    select: B1(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.mirror_type
    0:
      - H1(0..9)  # bit[9..0]: ingress::$tmp2
parser egress:
  start: $entry_point.start
  init_zero: [ B17, B16 ]
  bitwise_or: [ B16, B17 ]
  hdr_len_adj: 27
  meta_opt: 8191
  states:
    $entry_point.start:
      *:
        counter:
          imm: 24
        0..1: H16  # bit[7..15] -> H16 bit[8..0]: egress::eg_intr_md.egress_port
        27..28: H18  # egress::hdr.ethernet.dstAddr[47:32].32-47
        B17: 1  # value 1 -> B17 bit[0]: egress::hdr.ethernet.$valid
        intr_md: 9
        shift: 29
        buf_req: 29
        next: $entry_point.start.$oob_stall_0
    $entry_point.start.$oob_stall_0:
      *:
        0..3: W17  # egress::hdr.ethernet.dstAddr[31:0].0-31
        4..5: H17  # egress::hdr.ethernet.srcAddr[47:32].32-47
        6..9: W16  # egress::hdr.ethernet.srcAddr[31:0].0-31
        10..11: TH12  # egress::hdr.ethernet.etherType
        load: { half : 10..11 }
        shift: 12
        buf_req: 12
        next: $entry_point.start.$split_0
    $entry_point.start.$split_0:
      match: [ half ]
      0x0800:
        counter: dec 20
        0..3: TW4
            # - bit[0..3] -> TW4 bit[31..28]: egress::hdr.ipv4.version
            # - bit[4..7] -> TW4 bit[27..24]: egress::hdr.ipv4.ihl
            # - bit[8..15] -> TW4 bit[23..16]: egress::hdr.ipv4.diffserv
            # - bit[16..31] -> TW4 bit[15..0]: egress::hdr.ipv4.totalLen
        4..7: TW6
            # - bit[32..47] -> TW6 bit[31..16]: egress::hdr.ipv4.identification
            # - bit[48..50] -> TW6 bit[15..13]: egress::hdr.ipv4.flags
            # - bit[51..63] -> TW6 bit[12..0]: egress::hdr.ipv4.fragOffset
        8..11: TW5
            # - bit[64..71] -> TW5 bit[31..24]: egress::hdr.ipv4.ttl
            # - bit[72..79] -> TW5 bit[23..16]: egress::hdr.ipv4.protocol
            # - bit[80..95] -> TW5 bit[15..0]: egress::hdr.ipv4.hdrChecksum
        12..13: TH7  # egress::hdr.ipv4.srcAddr[31:16].16-31
        14..15: TH6  # egress::hdr.ipv4.srcAddr[15:0].0-15
        16..19: TW7  # egress::hdr.ipv4.dstAddr
        B17: 2  # value 1 -> B17 bit[1]: egress::hdr.ipv4.$valid
        shift: 20
        buf_req: 20
        next: min_parse_depth_accept_initial
      0x****:
        buf_req: 0
        next: min_parse_depth_accept_initial
    min_parse_depth_accept_initial:
      match: [ ctr_neg, ctr_zero ]
      option: ignore_max_depth
      0x0:
        counter: dec 11
        0: TB4  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[87:80].80-87
        1..2: TH13  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[79:64].64-79
        3..4: TH11  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[63:48].48-63
        5..6: TH10  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[47:32].32-47
        7..8: TH9  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[31:16].16-31
        B16: 4  # value 4 -> B16 bit[2..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 9
        buf_req: 9
        next: min_parse_depth_accept_loop.$split_0
      0b**:
        buf_req: 0
        next: end
    min_parse_depth_accept_loop.$split_0:
      match: [ ctr_neg, ctr_zero ]
      option: ignore_max_depth
      0x0:
        counter: dec 11
        0..1: TH8  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[15:0].0-15
        2: TB5  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[87:80].80-87
        3..4: TH14  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[79:64].64-79
        5..8: TW9  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[63:32].32-63
        9..12: TW8  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[31:0].0-31
        B16: 2  # value 2 -> B16 bit[2..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 13
        buf_req: 13
        next: min_parse_depth_accept_loop.$it1.$split_0
      0b**:
        0..1: TH8  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[15:0].0-15
        shift: 2
        buf_req: 2
        next: end
    min_parse_depth_accept_loop.$it1.$split_0:
      match: [ ctr_neg, ctr_zero ]
      option: ignore_max_depth
      0x0:
        counter: dec 11
        0: TB6  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[87:80].80-87
        1..2: TH15  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[79:64].64-79
        3..6: TW11  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[63:32].32-63
        7..10: TW10  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[31:0].0-31
        B16: 1  # value 1 -> B16 bit[2..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 11
        buf_req: 11
        next: end
      0b**:
        buf_req: 0
        next: end
deparser egress:
  dictionary:
    H18: B17(0)  # egress::hdr.ethernet.dstAddr.32-47 if egress::hdr.ethernet.$valid
    W17: B17(0)  # egress::hdr.ethernet.dstAddr.0-31 if egress::hdr.ethernet.$valid
    H17: B17(0)  # egress::hdr.ethernet.srcAddr.32-47 if egress::hdr.ethernet.$valid
    W16: B17(0)  # egress::hdr.ethernet.srcAddr.0-31 if egress::hdr.ethernet.$valid
    TH12: B17(0)  # egress::hdr.ethernet.etherType if egress::hdr.ethernet.$valid
    TW4: B17(1)
        # - bit[31..28]: egress::hdr.ipv4.version if egress::hdr.ipv4.$valid
        # - bit[27..24]: egress::hdr.ipv4.ihl if egress::hdr.ipv4.$valid
        # - bit[23..16]: egress::hdr.ipv4.diffserv if egress::hdr.ipv4.$valid
        # - bit[15..0]: egress::hdr.ipv4.totalLen if egress::hdr.ipv4.$valid
    TW6: B17(1)
        # - bit[31..16]: egress::hdr.ipv4.identification if egress::hdr.ipv4.$valid
        # - bit[15..13]: egress::hdr.ipv4.flags if egress::hdr.ipv4.$valid
        # - bit[12..0]: egress::hdr.ipv4.fragOffset if egress::hdr.ipv4.$valid
    TW5: B17(1)
        # - bit[31..24]: egress::hdr.ipv4.ttl if egress::hdr.ipv4.$valid
        # - bit[23..16]: egress::hdr.ipv4.protocol if egress::hdr.ipv4.$valid
        # - bit[15..0]: egress::hdr.ipv4.hdrChecksum if egress::hdr.ipv4.$valid
    TH7: B17(1)  # egress::hdr.ipv4.srcAddr.16-31 if egress::hdr.ipv4.$valid
    TH6: B17(1)  # egress::hdr.ipv4.srcAddr.0-15 if egress::hdr.ipv4.$valid
    TW7: B17(1)  # egress::hdr.ipv4.dstAddr if egress::hdr.ipv4.$valid
    TB4: B16(2)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TH13: B16(2)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TH11: B16(2)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.48-63 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TH10: B16(2)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.32-47 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TH9: B16(2)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.16-31 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TH8: B16(2)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.0-15 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TB5: B16(1)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TH14: B16(1)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TW9: B16(1)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.32-63 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TW8: B16(1)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.0-31 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TB6: B16(0)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TH15: B16(0)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TW11: B16(0)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.32-63 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TW10: B16(0)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.0-31 if egress::hdr.min_parse_depth_padding_0[2].$valid
  egress_unicast_port: H16(0..8)  # bit[8..0]: egress::eg_intr_md.egress_port
stage 0 ingress:
  phase0_match IngressParser.$PORT_METADATA:
    p4:
      name: IngressParser.$PORT_METADATA
      size: 288
      preferred_match_type: exact
      match_type: exact
    size: 288
    p4_param_order:
      ig_intr_md.ingress_port: { type: exact, size: 9 }
    format: {ig_intr_md: 0..63}
    constant_value: 0
    actions:
      set_port_metadata:
      - handle: 0x20000000
      - p4_param_order: { ig_intr_md: 64 } 
  ternary_match ipv4_lpm_0 1:
    p4: { name: Ingress.ipv4_lpm, size: 1024 }
    p4_param_order: 
      hdr.ipv4.dstAddr: { type: lpm, size: 32, full_size: 32 }
    row: [ 0, 1 ]
    bus: [ 0, 0 ]
    column:
    - 0
    - 0
    input_xbar:
      ternary group 0: { 0: hdr.ipv4.dstAddr }
    match:
    - { group: 0, byte_config: 3, dirtcam: 0x55 }
    gateway:
      name: cond-3
      input_xbar:
        exact group 0: { 25: hdr.ipv4.$valid }
      row: 0
      bus: 0
      unit: 0
      match: { 1: hdr.ipv4.$valid }
      0x1:
        run_table: true
      miss:
        next:  END
      condition: 
        expression: "(hdr.ipv4.$valid == 1)"
        true:  ipv4_lpm_0
        false:  END
    hit: [  END ]
    miss:  END
    indirect: ipv4_lpm_0$tind
  ternary_indirect ipv4_lpm_0$tind:
    row: 0
    bus: 0
    column: 2
    input_xbar:
      ternary group 0: { 0: hdr.ipv4.dstAddr }
    format: { action: 0..1, immediate: 2..10 }
    action_bus: { 36..37 : immediate(0..8) }
    instruction: ipv4_lpm_0$tind(action, $DEFAULT)
    actions:
      Ingress.ipv4_forward(1, 1):
      - p4_param_order: { port: 9 }
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000001
      - next_table: 0
      - { port: immediate(0..8) }
      - set ig_intr_md_for_tm.ucast_egress_port, port
      - add B0, 255, B0
      Ingress.drop(2, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000002
      - next_table: 0
      - {  }
      - set ig_intr_md_for_dprsr.drop_ctl, 1
      NoAction(3, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000003
      - next_table: 0
      - {  }
    default_action: Ingress.drop
stage 0 egress:
  exact_match next_hop_0 0:
    p4: { name: Egress.next_hop, size: 512 }
    p4_param_order: 
      eg_intr_md.egress_port: { type: exact, size: 9, full_size: 9 }
    row: 7
    bus: 0
    column: 2
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2]] }
    input_xbar:
      exact group 0: { 0: eg_intr_md.egress_port }
      hash 0:
        0..7: eg_intr_md.egress_port(0..7)
        8: eg_intr_md.egress_port(8)
      hash group 0:
        table: [0]
        seed: 0x0
    format: { action(0): 0..1, immediate(0): 2..33, version(0): 112..115 }
    match_group_map: [ [ 0 ] ]
    gateway:
      name: cond-4
      input_xbar:
        exact group 0: { 17: hdr.ipv4.$valid }
      row: 7
      bus: 0
      unit: 0
      match: { 1: hdr.ipv4.$valid }
      0x1:
        run_table: true
      miss:
        next:  END
      condition: 
        expression: "(hdr.ipv4.$valid == 1)"
        true:  next_hop_0
        false:  END
    hit: [  END ]
    miss:  END
    action_bus: { 96..99 : immediate(0..31) }
    action: next_hop_0$action_data($DIRECT, $DEFAULT)
    instruction: next_hop_0(action, $DEFAULT)
    actions:
      Egress.rewrite_mac(1, 1):
      - p4_param_order: { src_mac: 48, dst_mac: 48 }
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000004
      - next_table: 0
      - { src_mac.32-47: $adf_h0(0..15), dst_mac.32-47: $adf_h1(0..15), dst_mac.0-31: $adf_f1(0..31), src_mac.0-31: immediate(0..31) }
      - set hdr.ethernet.srcAddr.0-31, src_mac.0-31
      - set hdr.ethernet.srcAddr.32-47, src_mac.32-47
      - set hdr.ethernet.dstAddr.0-31, dst_mac.0-31
      - set hdr.ethernet.dstAddr.32-47, dst_mac.32-47
      NoAction(2, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000005
      - next_table: 0
      - {  }
    default_action: NoAction
  action next_hop_0$action_data:
    p4: { name: Egress.next_hop$action }
    row: 15
    logical_bus: A
    column: 0
    vpns: [ 0 ]
    home_row:
    - 15
    format Egress.rewrite_mac: { $adf_h0: 0..15, $adf_h1: 16..31, $adf_f1: 32..63 }
    action_bus: { 32..33 : $adf_h0, 34..35 : $adf_h1, 108..111 : $adf_f1 }


primitives: "simple_ipv4.prim.json"
dynhash: "simple_ipv4.dynhash.json"
